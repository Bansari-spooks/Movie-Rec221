# -*- coding: utf-8 -*-
"""BansariNimbalkar_Project-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGyg1-LnZuzmuczgDftE9SOvfUa_IsPx

**TASK** - 1 and **2**: **bold text** [1.]Import Dependencies

>
"""

# Import necessary libraries
import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
import difflib  # For finding the closest match of the movie title

"""**Task -2: Data Collection and Pre-Processing**

[2.]Loading Data From csv file to Pandas Data Frame
"""

df = pd.read_csv('/content/movies.csv')
df

"""[3.]Print first 5 Rows of Dataset"""

df.head(5)

"""[4.] Checking No. of Rows and Columns"""

df.shape

"""[5.]Select the relevant features for the recommendation"""

# Selecting the relevant features
features = ['title', 'overview', 'keywords', 'genres', 'cast', 'director']
df[features]

"""[6.] Replacing the Null Value with Null Strings


"""

df = df.fillna('Null')
df

"""[7.] Combining the selected features and Printing Them"""

# Combine selected features into a single string for each movie
df['combined_features'] = df['title'] + " " + df['overview'] + " " + df['keywords'] + " " + \
                                 df['genres'] + " " + df['cast'] + " " +df['director']
                                 # Combine selected features into a single string for each movie
df['combined_features']

"""[8.]Converting the Text Data to Feature Vector

"""

import difflib  # For partial matching

# Load the movie dataset
df = pd.read_csv('movies.csv')

# Fill missing values with empty strings
for feature in ['overview', 'keywords', 'genres', 'cast', 'director']:
    df[feature] = df[feature].fillna('')

# Combine relevant features into a single string
df['combined_features'] = df['overview'] + ' ' + df['keywords'] + ' ' + df['genres'] + ' ' + df['cast'] + ' ' + df['director']

# Use TF-IDF to convert text data into numerical vectors
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['combined_features'])

# Calculate cosine similarity based on the TF-IDF matrix
cosine_sim = cosine_similarity(tfidf_matrix)

# Function to get recommendations based on movie title (with partial matching)
def get_recommendations(title, cosine_sim=cosine_sim):
    # Find close matches for the movie title in the dataset
    close_matches = difflib.get_close_matches(title, df['title'], n=5, cutoff=0.4)

    # If no close matches are found, inform the user
    if not close_matches:
        print(f"Sorry, no movies found matching '{title}'.")
        return

    # If there are multiple close matches, prompt the user to select the correct one
    print(f"\nDid you mean one of these movies?")
    for i, match in enumerate(close_matches, 1):
        print(f"{i}. {match}")

    # Ask the user to select the correct movie by number
    try:
        choice = int(input("\nEnter the number of the correct movie (1, 2, 3, etc.): "))
        selected_title = close_matches[choice - 1]
    except (ValueError, IndexError):
        print("Invalid selection.")
        return

    # Get index of the selected movie
    idx = df[df['title'] == selected_title].index[0]

    # Get similarity scores for all movies
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort movies based on similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the indices of the top 10 similar movies (excluding the input movie)
    movie_indices = [i[0] for i in sim_scores[1:11]]

    # Print recommendations based on the selected movie
    print(f"\nBased on the movie '{selected_title}', here are some recommended movies for you:\n")
    recommendations = df['title'].iloc[movie_indices]

    for i, movie in enumerate(recommendations, 1):
        print(f"{i}. {movie}")

# Ask the user to input a movie title
user_movie = input("Enter a movie title for recommendations: ")

# Get recommendations based on the user's input
get_recommendations(user_movie)

"""**TASK- 3**

[1.]Cosine Similarity

   [a.]Getting the similarity scores using cosine similarity
"""

# Function to combine selected features for a given movie
def combine_features(row):
    combined = (
        f"Title: {row['title']}\n"
        f"Overview: {row['overview']}\n"
        f"Keywords: {row['keywords']}\n"
        f"Genres: {row['genres']}\n"
        f"Cast: {row['cast']}\n"
        f"Director: {row['director']}\n"
        f"Popularity: {row['popularity']}\n"
        f"Vote Average: {row['vote_average']}\n"
    )
    return combined

# Apply the function to each movie row and store combined features
df['combined_features'] = df.apply(combine_features, axis=1)

# Print the combined features for each movie (you can limit this to a few for readability)
for i in range(5):  # Print for first 5 movies
    print(f"Movie {i+1} Combined Features:\n{df['combined_features'].iloc[i]}")
    print('-' * 80)

"""[2.] Getting the Movie Name from the User

[a.] Getting the Movie Name from the User
"""

from difflib import get_close_matches

# Get the movie name from the user
movie_name = input("Enter a movie name: ")

"""[b.] Creating a list with all the movie names given in the Dataset"""

#List of all movie names in the dataset
all_titles = df['title'].tolist()
df['title'].tolist()

"""[c.] Finding the close match for the movie name given by the user"""

from difflib import get_close_matches

# Get the closest match
matches = get_close_matches(movie_name, all_titles, n=1)

# Check if any match was found
if matches:
    closest_match = matches[0]
    print("Closest match found:", closest_match)
else:
    print("No close match found for the entered movie name.")

"""[d.] Finding the index of the movie with title"""

# Get the index of the movie with the closest title
matched_indices = df[df['title'] == closest_match].index

if not matched_indices.empty:
    movie_index = matched_indices[0]
    print("Movie index found:", movie_index)
else:
    print("Movie title not found in DataFrame.")

"""[e.] Sorting the movies based on their similarity score"""

import difflib
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Read the dataset
df = pd.read_csv('movies.csv')

# Fill missing values with empty strings
for feature in ['overview', 'keywords', 'genres', 'cast', 'director']:
    df[feature] = df[feature].fillna('')

# Combine relevant features into a single string
df['combined_features'] = df['overview'] + ' ' + df['keywords'] + ' ' + df['genres'] + ' ' + df['cast'] + ' ' + df['director']

# Convert text data to feature vectors using TF-IDF
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(df['combined_features'])

# Calculate the cosine similarity matrix
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Function to get recommendations based on movie title (with partial matching)
def get_recommendations(title, cosine_sim=cosine_sim):
    # Clean the input title
    title = title.strip().lower()

    # Find close matches for the movie title in the dataset
    close_matches = difflib.get_close_matches(title, df['title'].str.lower(), n=5, cutoff=0.4)

    if not close_matches:
        print(f"Sorry, no movies found matching '{title}'.")
        return

    # If there are multiple close matches, prompt the user to select the correct one
    print(f"\nDid you mean one of these movies?")
    for i, match in enumerate(close_matches, 1):
        print(f"{i}. {match}")

    try:
        choice = int(input("\nEnter the number of the correct movie (1, 2, 3, etc.): "))
        selected_title = close_matches[choice - 1]
    except (ValueError, IndexError):
        print("Invalid selection.")
        return

    # Get the index of the selected movie
    idx = df[df['title'].str.lower() == selected_title].index[0]

    # Get similarity scores for all movies
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort movies based on similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the indices of the top 10 similar movies (excluding the input movie)
    movie_indices = [i[0] for i in sim_scores[1:11]]

    # Print recommendations based on the selected movie
    print(f"\nBased on the movie '{selected_title}', here are some recommended movies for you:\n")
    recommendations = df['title'].iloc[movie_indices]

    for i, movie in enumerate(recommendations, 1):
        print(f"{i}. {movie}")

# Ask the user to input a movie title
user_movie = input("Enter a movie title for recommendations: ")

# Get recommendations based on the user's input
get_recommendations(user_movie)